## Chapter 13. 함수형 관점으로 생각하기
람다, 일급함수, 객체변화 제한

### 13.1 시스템 구현과 유지보수
* 스트림을 이용하려면 상태 없는 동작이여야한다.
* 함수형 프로그래밍이 제공하는 no side effect, immutalility라는 개념은 레거시 유지보수 중 예상치 못한 변수값에 의한 코드 크래시 방지에 도움을 줄 수 있다.

#### 13.1.1 공유된 가변 데이터 
* 순수 또는 부작용 없는 메서드
	* 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드 	

#### 13.1.2 선언형 프로그래밍
* 내부 반복프로그래밍
	* 질의문 자체로 문제를 어떻게 푸는지 명확하게 보여줌 (질의문 구현은 라이브러리가 결정)
* 어떻게(how)로 접근하는 방식
* 예제 코드는 Chapter 05의 트랜젝션 코드로 경험했으니 그것을 참고.
* 선언형 프로그래밍의 장점
	* 문제 자체가 코드로 명확하게 드러나는 점

#### 13.1.3 왜 함수형 프로그래밍인가?
* 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식


### 13.2 함수형 프로그래밍이란 무엇인가?
* 함수를 이용하는 프로그래밍이다
* 그럼 함수는 무엇?
	* 수학적인 함수와 같음
	* 0개 이상의 인수를 가지며 1개 이상의 결과를 반환하지만 부작용이 없어야한다.  
(side effect가 없어야함을 말하는 것 같음.)
* Java에서는 함수와 메서드의 구분을 수학적인 함수냐 아니냐로 구분
* 인수가 같다면 수학적 함수를 반복적으로 호출 했을 때 항상 같은 결과를 반환

* 순수 함수형
	* 함수 그리고 if-then-else 등의 수학적 표현만 사용하는 방식
* 함수형 프로그래밍 
	* 시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용하는 방식

#### 13.2.1 함수형 자바
* `함수형`이라면..
	* 함수나 메서드가 지역 변수만을 변경해아함
	* 객체의 모든 필드가 final 및 모든 참조 필드는 불변 격체를 직접 참조해야함.
	* 예외적으로는..
		* 메서드 내에서 생성한 객체의 필드는 갱신할 수 있음.
			* 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야함. 
			* 다음에 메서드를 다시 호출한 결과에 영향을 미치지 않아야함.
	* 함수나 메서드가 어떤 예외도 일으키지 않아야 함.
		* 블랙박스 모델에서 return으로 결과를 반환할 수 없게 되므로.
		* 그러나 Java에서는  예외를 발생시킬 수 있고, Optional을 활용해볼 수 있음.

#### 13.2.2 참조 투명성
* 같은 인수로 함수를 호출 했을 때 항상 같은 결과 반환

#### 13.2.3 객체지향 프로그래밍과 함수형 프로그래밍
* 스팩트럼의 한쪽 끝
	* 익스트림 객체지향 방식
		* 모든 것을 객체로 간주
		* 프로그램이 객체의 필드를 갱신
		* 메서드 호출
		* 관련 객체를 갱신
* 또다른 한쪽 끝
	* 함수형 프로그래밍
		* 참조적 투명성을 중시
		* 변화를 허용하지 않는...
* 두 가지 방식을 혼합하는 프로그래밍 방식으로 진행...

#### 13.2.4 함수형 실전 연습
* chapter13 패키지에서 예제 코드 작성 (FunctionalStyleInPracticeTest)
	* 역시 재귀가 들어가면 해깔림.. 천천히보자.

### 13.3 재귀와 반복
* chapter13 패키지에서 예제 코드 작성  (RecursionVsIterationTest)

### 13.4 요약
* 공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지보수하고 디버깅하는데 도움이 됨.
* 함수형 프로그래밍은 부작용이 없는 (no side effect) 메서드와 선언형 프로그래밍 방식(how)을 지향
* 자바에서는 고전 방식의 재귀보다는 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있음.